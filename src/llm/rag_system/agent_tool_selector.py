"""
Agent-based tool selection for genomic analysis tasks.

Replaces brittle regex pattern matching with intelligent LLM-based tool selection
that preserves biological intent and context through the task execution pipeline.
"""

import logging
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass
import json

try:
    import dspy
    DSPY_AVAILABLE = True
except ImportError:
    DSPY_AVAILABLE = False

from .external_tools import AVAILABLE_TOOLS, TOOL_CAPABILITIES
from .memory.model_allocation import get_model_allocator

logger = logging.getLogger(__name__)


@dataclass
class ToolSelectionResult:
    """Result from agent-based tool selection."""
    selected_tool: Optional[str]
    tool_arguments: Dict[str, Any]
    reasoning: str
    confidence: float
    fallback_used: bool = False


class AgentToolSelector(dspy.Signature if DSPY_AVAILABLE else object):
    """Agent intelligently selects genomic analysis tools based on biological context."""
    
    task_description = dspy.InputField(desc="Description of the genomic analysis task to perform")
    original_user_query = dspy.InputField(desc="Original user question for biological context preservation")
    available_tools = dspy.InputField(desc="JSON list of available tools and their capabilities")
    previous_task_context = dspy.InputField(desc="Context from previous tasks in the workflow")
    
    selected_tool = dspy.OutputField(desc="Exact tool name from available_tools, or 'database_query' for direct database access")
    tool_arguments = dspy.OutputField(desc="Valid JSON object with arguments for the selected tool (no comments, proper JSON syntax)")
    biological_reasoning = dspy.OutputField(desc="Biological reasoning for why this tool accomplishes the analysis goal")
    use_this_tool = dspy.OutputField(desc="YES if confident in tool selection, NO if should fallback to regex patterns")


class BiologicalIntentClassifier(dspy.Signature if DSPY_AVAILABLE else object):
    """Preserve biological intent through task planning pipeline."""
    
    original_query = dspy.InputField(desc="Original user query with biological intent")
    task_description = dspy.InputField(desc="Task description generated by planner")
    
    biological_intent = dspy.OutputField(desc="spatial_genomic|functional_annotation|comparative_analysis|database_query")
    requires_spatial_analysis = dspy.OutputField(desc="true|false - whether task needs spatial genome reading")
    requires_whole_genome_view = dspy.OutputField(desc="true|false - whether task needs complete genome context")
    recommended_tool = dspy.OutputField(desc="whole_genome_reader|code_interpreter|genome_selector|literature_search|database_query")
    preservation_reasoning = dspy.OutputField(desc="How this classification preserves the original biological intent")


class IntelligentToolSelector:
    """
    Intelligent tool selection system that uses LLM reasoning instead of regex patterns.
    
    Features:
    - Agent-based tool selection with biological context awareness
    - Original query context preservation through the pipeline
    - Fallback to regex patterns for reliability
    - Tool capability awareness and semantic matching
    """
    
    def __init__(self):
        """Initialize the intelligent tool selector."""
        self.model_allocator = get_model_allocator()
        self.agent_selector = None
        self.intent_classifier = None
        
        # Use tool capabilities from external_tools
        self.tool_capabilities = TOOL_CAPABILITIES
        
        # Initialize DSPy modules if available
        if DSPY_AVAILABLE:
            self.agent_selector = dspy.Predict(AgentToolSelector)
            self.intent_classifier = dspy.Predict(BiologicalIntentClassifier)
            logger.info("ü§ñ Agent-based tool selector initialized with DSPy")
        else:
            logger.warning("‚ö†Ô∏è DSPy not available - falling back to regex-only selection")
    
    
    async def select_tool_for_task(self, 
                                 task_description: str,
                                 original_user_query: str,
                                 previous_task_context: str = "") -> ToolSelectionResult:
        """
        Select the appropriate tool for a genomic analysis task.
        
        Args:
            task_description: Description of the task to perform
            original_user_query: Original user query for context preservation
            previous_task_context: Context from previous tasks in workflow
            
        Returns:
            ToolSelectionResult with selected tool and reasoning
        """
        logger.info(f"üéØ Selecting tool for task: {task_description[:100]}...")
        
        # Try agent-based selection first
        if self.agent_selector:
            try:
                agent_result = await self._agent_based_selection(
                    task_description, original_user_query, previous_task_context
                )
                if not agent_result.fallback_used:
                    # Agent made a decision - accept it regardless of tool type
                    tool_name = agent_result.selected_tool or "database_query"
                    logger.info(f"ü§ñ Agent selected: {tool_name} (confidence: {agent_result.confidence:.2f})")
                    return agent_result
            except Exception as e:
                logger.error(f"üí• agent_fail: {type(e).__name__}: {e}")
                import traceback
                logger.debug(f"üêõ trace: {traceback.format_exc()}")
        
        # Fallback to regex-based selection
        logger.warning("üîÑ fallback_to_regex")
        return self._regex_based_selection(task_description, original_user_query)
    
    async def _agent_based_selection(self, 
                                   task_description: str,
                                   original_user_query: str,
                                   previous_task_context: str) -> ToolSelectionResult:
        """Use LLM agent to select tool based on biological reasoning."""
        
        # Prepare available tools context
        available_tools_json = json.dumps(self.tool_capabilities, indent=2)
        
        # Use model allocation for intelligent tool selection (complex task = o3)
        def selection_call(module):
            return module(
                task_description=task_description,
                original_user_query=original_user_query,
                available_tools=available_tools_json,
                previous_task_context=previous_task_context
            )
        
        # Use o3 for tool selection (complex biological reasoning)
        logger.debug(f"üî• o3_call: task='{task_description[:50]}...'")
        result = self.model_allocator.create_context_managed_call(
            task_name="tool_selection",  # Maps to COMPLEX = o3
            signature_class=AgentToolSelector,
            module_call_func=selection_call,
            query=original_user_query,
            task_context=task_description
        )
        
        logger.debug(f"üî• o3_result: type={type(result)}, val={result}")
        
        if not result:
            logger.error("‚ùå o3_call: Model allocation returned None")
            raise Exception("Model allocation failed for tool selection")
        
        # Debug: Check result attributes
        has_selected = hasattr(result, 'selected_tool')
        has_args = hasattr(result, 'tool_arguments') 
        has_reasoning = hasattr(result, 'biological_reasoning')
        has_decision = hasattr(result, 'use_this_tool')
        logger.debug(f"üîç o3_attrs: tool={has_selected}, args={has_args}, reason={has_reasoning}, decision={has_decision}")
        
        if has_selected:
            logger.debug(f"üì§ o3_tool: '{result.selected_tool}'")
        if has_args:
            logger.debug(f"üõ†Ô∏è o3_args: '{result.tool_arguments}'")
        if has_decision:
            logger.debug(f"üéØ o3_decision: '{result.use_this_tool}'")
        
        # Parse tool arguments
        try:
            # Clean o3's JSON responses (remove comments and fix formatting)
            cleaned_json = self._clean_json_response(result.tool_arguments) if result.tool_arguments else "{}"
            tool_args = json.loads(cleaned_json)
            logger.debug(f"‚úÖ parsed_args: {len(tool_args)} keys")
        except json.JSONDecodeError as e:
            logger.warning(f"‚ùå json_parse_fail: {e}")
            logger.warning(f"üìù raw_args: {result.tool_arguments}")
            tool_args = {"description": task_description}
        
        # Validate selected tool
        selected_tool = result.selected_tool
        logger.debug(f"üéØ raw_tool: '{selected_tool}'")
        if selected_tool not in AVAILABLE_TOOLS and selected_tool != "database_query":
            logger.warning(f"‚ùå invalid_tool: '{selected_tool}' not in {list(AVAILABLE_TOOLS.keys())}")
            selected_tool = "database_query"
        
        # Binary decision instead of confidence threshold
        use_tool = getattr(result, 'use_this_tool', 'NO').upper().strip() == 'YES'
        logger.debug(f"üéØ use_decision: {use_tool}")
        
        # Return result based on binary decision
        if use_tool:
            # Agent said YES - accept its choice
            # For database_query, return None as selected_tool to indicate ATOMIC_QUERY
            if selected_tool == "database_query":
                return ToolSelectionResult(
                    selected_tool=None,  # None means ATOMIC_QUERY (database query)
                    tool_arguments=tool_args,
                    reasoning=result.biological_reasoning,
                    confidence=1.0,  # High confidence since agent said YES
                    fallback_used=False
                )
            else:
                # Real tool selected
                return ToolSelectionResult(
                    selected_tool=selected_tool,
                    tool_arguments=tool_args,
                    reasoning=result.biological_reasoning,
                    confidence=1.0,  # High confidence since agent said YES
                    fallback_used=False
                )
        else:
            # Agent said NO - use fallback
            logger.info(f"üîÑ o3_says_NO: decision='{getattr(result, 'use_this_tool', 'MISSING')}'")
            raise Exception("Agent said NO, use regex fallback")
    
    def _regex_based_selection(self, 
                             task_description: str,
                             original_user_query: str) -> ToolSelectionResult:
        """Fallback regex-based tool selection (existing logic)."""
        
        # Import existing patterns from task_plan_parser
        from .task_plan_parser import TaskPlanParser
        parser = TaskPlanParser()
        
        # Use DIRECT regex classification to avoid infinite recursion
        task_type, tool_name = parser._classify_task_type_regex(task_description)
        
        if tool_name:
            # Extract basic tool arguments
            tool_args = {
                "description": task_description,
                "task_context": "genomic_analysis"
            }
            
            # Add specific arguments based on tool
            if tool_name == "whole_genome_reader":
                # Check for spatial analysis indicators
                if any(keyword in (task_description + " " + original_user_query).lower() 
                       for keyword in ["spatial", "operon", "prophage", "clustering", "neighborhood"]):
                    tool_args.update({
                        "global_analysis": True,
                        "focus_on_spatial": True,
                        "max_genes_per_contig": 10000  # Increased from 1000 to avoid truncating prophage loci
                    })
            
            return ToolSelectionResult(
                selected_tool=tool_name,
                tool_arguments=tool_args,
                reasoning=f"Regex pattern matched for {tool_name}",
                confidence=0.6,  # Lower confidence for regex
                fallback_used=True
            )
        
        # No tool selected - default to database query
        return ToolSelectionResult(
            selected_tool=None,
            tool_arguments={"description": task_description},
            reasoning="No specific tool pattern matched, using database query",
            confidence=0.5,
            fallback_used=True
        )
    
    async def classify_biological_intent(self, 
                                       original_query: str,
                                       task_description: str) -> Dict[str, Any]:
        """Classify biological intent to preserve context through pipeline."""
        
        if not self.intent_classifier:
            return {
                "biological_intent": "unknown",
                "requires_spatial_analysis": False,
                "requires_whole_genome_view": False,
                "recommended_tool": "database_query",
                "preservation_reasoning": "DSPy not available for intent classification"
            }
        
        try:
            # Use model allocation for biological intent classification (complex task = o3)
            def classification_call(module):
                return module(
                    original_query=original_query,
                    task_description=task_description
                )
            
            result = self.model_allocator.create_context_managed_call(
                task_name="biological_interpretation",  # Maps to COMPLEX = o3
                signature_class=BiologicalIntentClassifier,
                module_call_func=classification_call,
                query=original_query,
                task_context=task_description
            )
            
            if result:
                return {
                    "biological_intent": result.biological_intent,
                    "requires_spatial_analysis": result.requires_spatial_analysis.lower() == "true",
                    "requires_whole_genome_view": result.requires_whole_genome_view.lower() == "true",
                    "recommended_tool": result.recommended_tool,
                    "preservation_reasoning": result.preservation_reasoning
                }
        
        except Exception as e:
            logger.warning(f"Biological intent classification failed: {e}")
        
        # Fallback classification
        return {
            "biological_intent": "unknown",
            "requires_spatial_analysis": False,
            "requires_whole_genome_view": False,
            "recommended_tool": "database_query",
            "preservation_reasoning": "Fallback classification due to error"
        }
    
    def _clean_json_response(self, json_str: str) -> str:
        """
        Clean o3's JSON responses by removing comments and fixing formatting.
        
        Args:
            json_str: Raw JSON string from o3 that may contain comments
            
        Returns:
            Cleaned JSON string that can be parsed
        """
        import re
        
        if not json_str or not json_str.strip():
            return "{}"
        
        # Remove line comments (// ...)
        json_str = re.sub(r'//.*?(?=\n|$)', '', json_str)
        
        # Remove block comments (/* ... */)
        json_str = re.sub(r'/\*.*?\*/', '', json_str, flags=re.DOTALL)
        
        # Remove trailing commas before closing braces/brackets
        json_str = re.sub(r',\s*([}\]])', r'\1', json_str)
        
        return json_str.strip()


# Global instance for easy access
_tool_selector = None

def get_tool_selector() -> IntelligentToolSelector:
    """Get the global tool selector instance."""
    global _tool_selector
    if _tool_selector is None:
        _tool_selector = IntelligentToolSelector()
    return _tool_selector